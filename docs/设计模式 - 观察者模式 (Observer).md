---
title: 观察者模式 (Observer)
uid: 20240123112807456
aliases: []
categories: []
tags:
  - 计算机/设计模式/GoF设计模式/行为型模式
archive: false
draft: false
todo: false
createTime: 2023-05-07 22:01:31
updateTime: 2024-08-02 13:59:18
---

观察者模式

1. 观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自
   动更新。
2. 观察者模式是一种对象行为型模式，其别名为发布 - 订阅模式、模型 - 视图模式、源 - 监听器模式或从属者
   模式。
3. 观察者模式包含四个角色：
   1. 抽象主题（Subject）角色：抽象主题角色把所有观察者对象的引用保存在一个集合中，每个主题都可以有
      任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
   2. 具体主题（ConcreteSubject）角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给
      所有登记过的观察者发出通知。
   3. 抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。
   4. 具体观察者（ConcreteObserver）角色：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题
      的状态协调。
4. 观察者模式的优点：
   1. 观察者和被观察者之间是抽象耦合的。
   2. 建立一套触发机制。
5. 观察者模式的缺点：
   1. 如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。
   2. 如果在观察者和被观察者之间存在循环依赖，观察者会等待被观察者通知，而被观察者又在等待观察者的处
      理，就会导致系统崩溃。
   3. 观察者之间有过多的细节依赖，提高时间消耗及程序复杂度。
   4. 使用要得当，要避免循环调用。
6. 观察者模式的适用场景：
   1. 关联行为场景。需要注意的是，关联行为是可拆分的，而不是 " 组合 " 关系。
   2. 事件多级触发场景。
   3. 跨系统的消息交换场景，如消息队列的处理机制。
7. 观察者模式的扩展：
   1. 可以使用观察者模式实现事件委托机制。
   2. 可以使用观察者模式实现远程发布 - 订阅模式。
   3. 可以使用观察者模式实现消息队列的处理机制。
   4. 可以使用观察者模式实现一对多的消息传递机制。
   5. 可以使用观察者模式实现跨系统的消息交换机制。
8. 观察者模式的注意事项：
   1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这两者封装在独立的对象中使它们可以各自
      独立地改变和复用。
   2. 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
   3. 一个对象必须通知其他对象，而并不知道这些对象是谁。
   4. 需要在不同时间指定不同的对象，作为此对象的通知接收者。
9. 观察者模式的应用实例：
   1. 在软件构建过程中，当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时，可以
      考虑使用观察者模式。
   2. 在对象之间存在一对多关系时，可以考虑使用观察者模式（比如，从图书馆到读者）。
   3. Java 中的 AWT 和 Swing 中的事件处理机制就是典型的观察者模式应用。
   4. MVC 框架中的 C（控制器）就是一个典型的观察者模式。
   5. Android 中的广播机制也是观察者模式的典型应用。

## 参考

- [理解【观察者模式】和【发布订阅】的区别](https://juejin.cn/post/6978728619782701087)
